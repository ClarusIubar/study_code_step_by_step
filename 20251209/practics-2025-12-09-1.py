me = {
    "name" : "유효현",
    "age" : 100,
    "home" : "대전"
}

print(me["name"])

# 엠(M)이(E)라는 객체(묶음방식, 딕셔너리)를 선언(statement)했다.
# name, age, home으로 구성된 객체(딕셔너리) 값을 할당(assignment)했다.
# 초기화(initialize)한다. -> init 
# 초기화했어? -> 적절하게 값과 이름을 준비했니?

# 딕셔너리 : key(열쇠), value(값)
# 속성(property) : key, value를 갖춘 상황 -> field, entity
# 등호(=) : 할당 연산자(assignment operator), 이항 연산자 : 우항에서 좌항으로 할당

# 식판에 김치부분 가져와
# me에 [김치]가져와 <- 데이터 접근 표기법 - 괄호접근법(bracket notation **)

you = ["전민권", "박미주", "이세한", "신재혁"]
print(you[2])

# digit(자릿수) -> digital
# 개발에서는 자릿수 문제 때문에 0부터 시작하도록 설계되어 있음.
# index(목차, 색인) : 순서를 따줄 때는 0부터 시작하는 것이 국룰이다.
# 0번째 == 첫번째 (순서) / 한개 == 하나 (카운팅)

# 일반적인 특징
# 객체(딕셔너리) -> 접근할 때 '문자열'을 쓰는 편
# 배열(리스트) -> 전근할 때 '숫자'로 쓰는 편
# 실행부분만 봐도 대충 판단은 가능함 -> '추론'

another = {
    0 : "고경명",
    1 : "김성진",
    2 : "박상현"
}
# 배열은 객체의 자식이다. # 원래는 이렇게 쓰다가 편하게 쓰려고 탄생함. 인덱싱은 알아서 해주는 방식으로 []
print(another[2])

